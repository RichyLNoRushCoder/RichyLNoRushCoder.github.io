<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>备考雅思:2026-01-23</title>
    <link href="/2026/01/23/English-20260123/"/>
    <url>/2026/01/23/English-20260123/</url>
    
    <content type="html"><![CDATA[<p>今日英语学习依然在第一阶段：打基础+学习阅读技巧</p><ul><li><input disabled="" type="checkbox"> 单词过两遍</li><li><input disabled="" type="checkbox"> 语料库听写一遍</li><li><input disabled="" type="checkbox"> 阅读课过一遍</li></ul><h3 id="1-背单词"><a href="#1-背单词" class="headerlink" title="1.背单词"></a>1.背单词</h3><p>今日时间充足，加油啊，继续好好学英语，我今年一定要把英语变成技能。<br>今日份学习，加油加油<br><img src="/images/English/data_20260123.png" alt="今日学习数据"></p><h3 id="2-雅思王听力"><a href="#2-雅思王听力" class="headerlink" title="2.雅思王听力"></a>2.雅思王听力</h3><p>今日听了chapter11 section2 的连读部分<br>很多单词不会<br>明天继续复习这一部分</p>]]></content>
    
    
    <categories>
      
      <category>备考雅思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English_Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好的数据对于 LLM 有什么用？——从“数据搬运工”到“库内推理”的范式转移</title>
    <link href="/2026/01/23/good-data-for-llm/"/>
    <url>/2026/01/23/good-data-for-llm/</url>
    
    <content type="html"><![CDATA[<p>今天我们来聊一聊：“好的数据”对于 LLM 到底有什么用？</p><p>大家都知道数据是大模型的基础，质量决定效果。但随着 AI 卷得越来越厉害，算法同学的作用似乎越来越大，反观我们做数据的，作用好像慢慢被弱化了。</p><p>现在的痛点很真实：Java&#x2F;SQL 写不过 AI，业务理解干不过数分。<strong>那我们数据人还能干什么呢？</strong></p><p>其实 AI 跑得再快，现在也慢慢碰到“数据天花板”了。很多企业现在的瓶颈不再是“算力不够”，而是“数据供不上”。</p><h3 id="1-现有的-Data-for-AI-到底出了什么问题？"><a href="#1-现有的-Data-for-AI-到底出了什么问题？" class="headerlink" title="1. 现有的 Data for AI 到底出了什么问题？"></a>1. 现有的 Data for AI 到底出了什么问题？</h3><p>看上去企业数据资产不少，但真正能直接拿来训练、推理的比例并不高，主要是因为这几个坑：</p><ol><li><strong>数据类型对不上</strong>：现在企业大部分数据是二维表格，适合做报表。但模型更需要向量（表达语义）、图结构（表达关系）、时间序列（表达变化）。<strong>本质上，现有数据的组织方式和模型的需求“不兼容”。</strong></li><li><strong>维度不够</strong>：传统指标讲究“少而精”，字段得能解释。但模型往往靠大量稠密特征，很多特征单看没意义，组合起来才是宝。</li><li><strong>时效性太差</strong>：传统数据按天、按周更新，复盘够了，但推荐、风控这种实时决策，模型需要的是“现在”的数据，而不是“昨天”的。</li><li><strong>工具没用好</strong>：数据圈有很多成熟的实时处理、任务调度工具，但现在还没跟 AI 流程很好地合体。</li></ol><h3 id="2-具体的解决方案"><a href="#2-具体的解决方案" class="headerlink" title="2. 具体的解决方案"></a>2. 具体的解决方案</h3><p><strong>第一，从存储角度：</strong><br>得搞<strong>湖仓一体</strong>。在能存下多模态数据（图片、文档等）的基础上，增加快速调用的功能，别让数据躺在里面睡觉。</p><p><strong>第二，从推理角度：</strong></p><p>现在的方案太长：</p><blockquote><p><strong>数据库读 Page → 序列化发网络包 → 应用层反序列化 → 转为 Tensor → 最后才交给 GPU。</strong></p></blockquote><p>这就好比你在书架上找一本书，为了读它，你得先复印一份，装进快递盒寄回家，拆开后再翻译成母语，最后才开始读。</p><p><strong>我们更希望的是：</strong></p><ul><li><strong>零拷贝（Zero-Copy）思想</strong>：数据在数据库内存（Buffer Pool）里刚解开，别封装了，原地直接通过内置算子变向量。</li><li><strong>内存直接交付</strong>：Embedding 后的张量（Tensor）通过内存地址指针，直接甩给旁路挂载的推理引擎。</li></ul><p><strong>核心就是把计算向存储前移，能少搬数据就少搬。</strong></p><h3 id="3-我们可以利用哪些数据库的“老本行”优势？"><a href="#3-我们可以利用哪些数据库的“老本行”优势？" class="headerlink" title="3. 我们可以利用哪些数据库的“老本行”优势？"></a>3. 我们可以利用哪些数据库的“老本行”优势？</h3><ol><li><strong>索引能力</strong><br>做数据的都知道，索引能救命。如果没有索引，匹配问题就得全量扫描。<br><strong>举个例子：</strong> 如果提示词（Prompt）太长，模型每次都要重复计算 KV 矩阵，开销极大。但如果我们把这些值存入磁盘&#x2F;内存，并建立索引，下次就能直接命中之前的推理状态，从中间状态直接开跑。</li><li><strong>并行调度能力</strong><br>虽然并行是 GPU 的强项，但 GPU 必须从内存拉数据，搬运时间太长。数据库可以直接在内存里并行计算。而且如果把计算都看作“算子”，就能利用数据库成熟的任务调度和优先级管理，谁先跑谁后跑，管得明明白白。</li><li><strong>数据一致性（ACID）</strong><br>这是数据库的拿手好戏。如果直接在库内读向量做推理，只要数据库里的数据一变，模型拿到的结果立刻跟着变，业务响应极快，不用担心模型读到的是旧数据。</li><li><strong>硬约束（纠正幻觉）</strong><br>利用<strong>强 Schema 和约束</strong>。比如通过内置的图数据库算子，给推理加个“紧箍咒”。<br><strong>例子：</strong> 模型想推理“A 公司的 CEO 是谁”，向量检索可能搜到一堆八卦，但数据库会先查内部的关系图谱（确定的事实），如果是 B，就强制模型按这个输出。<strong>用“确定性”去纠正 AI 的“概率性”。</strong></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以后我们得解决这几个关键问题：</p><ol><li>怎么利用索引快速定位有效数据？</li><li>怎么利用数据库的大规模计算和贴近内存的特点，给训练和存储加速？</li><li>怎么利用事务能力，保证模型快速响应业务？</li><li>怎么利用数据库的“确定性”去纠偏？</li></ol><p>作为数据人的一份子，我很希望看到 AI 消费数据、理解数据，而数据反过来塑造 AI。</p><p><strong>不过说真的，如果这些都实现了，数据人是不是真的得去找新工作了？</strong></p>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
      <category>Data for AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Agent</tag>
      
      <tag>LLM</tag>
      
      <tag>Data</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单了解期权</title>
    <link href="/2026/01/20/finance-20260120/"/>
    <url>/2026/01/20/finance-20260120/</url>
    
    <content type="html"><![CDATA[<h3 id="1-一句话说明：期权"><a href="#1-一句话说明：期权" class="headerlink" title="1. 一句话说明：期权"></a>1. 一句话说明：期权</h3><p>买方：花钱购买未来以固定价格买某样东西的权利</p><p>卖房：拿钱，但是必须在未来把某样资产以固定价格卖给买方</p><h3 id="2-举个例子："><a href="#2-举个例子：" class="headerlink" title="2. 举个例子："></a>2. 举个例子：</h3><p>现在股票A是100元一股，你有1000元，你如果直接买的话，只能买10股，假设未来三个月股票涨到150元，一共赚了$50*10&#x3D;500$元。</p><p>如果用期权，假设一股的权利金是10元，你可以购买100股的期权。<br>这个期权决定了，在未来三个月，你可以用110元购买股票。<br>你还有资金11000元，你可以用这11000元购买110股股票，假设股票涨到150元，一共赚了$（50-10）<em>100&#x3D;4000$元。<br>如果你没有其他资金，你也可以把这个期权卖出，期权现在的价格在40左右波动（别人买了这个期权，一股最少能省40，未来还可能更多），你可以$40</em>100&#x3D;4000$赚，净赚3000元。</p><h3 id="3-两个简单的期权模式："><a href="#3-两个简单的期权模式：" class="headerlink" title="3. 两个简单的期权模式："></a>3. 两个简单的期权模式：</h3><ol><li><p>看跌期权<br>期权有一个很神奇的地方，就是你可以卖出你没有的东西。<br>比如看跌期权。<br>假设你有9000元现金，股票A现在100元。你可以一股10元卖出自己的看跌期权，卖100股，担保：<br>在未来某个时间点，股票A价格不管跌到多少，我都以90元的价格购买。你承担了接盘的风险。<br>如果股票A的价格涨了，和你交易的人觉得卖给你亏了，那你赚了保证金1000元。<br>假设股票A的价格降到了85，你依然得以90元一股购买股票，你花9000元，获得了<em>85</em>100+1000&#x3D;9500元*。还是赚了500元。<br>但是跌的更低，可就亏了。</p></li><li><p>看涨期权<br>看涨期权和看跌期权是相反的。<br>如果你手里已经持有了一些股票（比如你打算长期持有的公司），你可以每个月给它们“收租”。每个月卖出一份远高于当前市价的看涨期权（Call）。只要股票没在短期内暴涨，你就白赚一份权利金。如果真的暴涨了，你就按高价把股票卖掉，反正你也赚了。这能极大地对冲你持股时的心理波动，在震荡市中，这部分“租金”往往能贡献 5%-10% 的额外年化收益。<br>想象一下，你是个硬件发烧友。英伟达发布了一款新显卡，现在市价 1000元。你手里暂时没钱，但你觉得三个月后因为 AI 爆发，这卡肯定会涨到 2000 元。你付给店老板 50元 签了一份合同：“三个月后的今天，我有权按 1000 元的价格从你这买一张显卡。”<br>如果大涨到 2000 元：你拿合同找老板，老板必须按 1000 元卖给你。你转手一卖，扣掉 50 元合同费，净赚 950 元！<br>如果没涨（甚至跌了）：你发现市场上这显卡只要 800 元了。你肯定不会按 1000 元买，你直接撕毁合同，损失就是那 50元 的合同费。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
      <category>Finance</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>Finance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备考雅思:2026-01-20</title>
    <link href="/2026/01/20/English-20260120/"/>
    <url>/2026/01/20/English-20260120/</url>
    
    <content type="html"><![CDATA[<p>今日份学习，加油加油<br><img src="/images/English/data_20260120.png" alt="今日学习数据"><br>今日英语学习依然在第一阶段：打基础+学习阅读技巧</p><ul><li><input disabled="" type="checkbox"> 单词过两遍</li><li><input disabled="" type="checkbox"> 语料库听写一遍</li><li><input disabled="" type="checkbox"> 阅读课过一遍</li></ul><h3 id="1-背单词"><a href="#1-背单词" class="headerlink" title="1.背单词"></a>1.背单词</h3><p>今日时间充足，加油啊，继续好好学英语，我今年一定要把英语变成技能。</p>]]></content>
    
    
    <categories>
      
      <category>备考雅思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English_Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>life_20260118</title>
    <link href="/2026/01/18/life-20260118/"/>
    <url>/2026/01/18/life-20260118/</url>
    
    <content type="html"><![CDATA[<p>今晚沉浸于《WhynotTV》何泰然与翁家翌的深度对话，仿佛目睹两颗清华星辰的碰撞。他们的思维密度与认知高度，令我这样的普通听众唯有仰望的份。</p><p>虽非算法领域从业者，但我对翁家翌在开源世界的贡献怀有深深的敬意。正是这些先行者留下的开源项目与经验沉淀，为无数像我这样非科班、非名校出身的探索者，点亮了前行的微光。</p><p>这期播客最触动我的，是翁家翌那套清晰而稳固的个人评价体系。他很早就构建了一套内在的坐标系，让自己能够最大程度地摆脱外界评价体系的引力，按照自己的逻辑去生活、去行动。这样的活法未必轻松，但一定足够自洽。</p><p>当何泰然问及是否担心自己的这套体系未来也会演变成像GPA那样令人窒息的内卷时，翁家翌的回答掷地有声：“我不害怕。”</p><p>我理解，这两套体系的核心区别在于，社会主流的评价体系（如GPA、地位）往往带有零和博弈的侵略性——你的拥有，意味着我的稀缺。而翁家翌的内在体系，则指向一种正和的、共同成长的共赢状态。</p><p>我或许无法企及翁神那般卓越的代码造诣与行业影响力，也无法构建他那样宏大的个人坐标系。但我愿意从微小处着手，建立属于自己的朴素标准。</p><p><strong>比昨天懂得更多，成为更好的自己</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Thoughts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备考雅思:2026-01-17</title>
    <link href="/2026/01/17/English_20260116/"/>
    <url>/2026/01/17/English_20260116/</url>
    
    <content type="html"><![CDATA[<p>今日份学习，加油加油<br><img src="/images/English/data_20260117.png" alt="今日学习数据"><br>今日英语学习依然在第一阶段：打基础+学习阅读技巧</p><ul><li><input disabled="" type="checkbox"> 单词过两遍</li><li><input disabled="" type="checkbox"> 语料库听写一遍</li><li><input disabled="" type="checkbox"> 阅读课过一遍</li></ul><h3 id="1-背单词"><a href="#1-背单词" class="headerlink" title="1.背单词"></a>1.背单词</h3><p>今日时间不够<br>复习单词25min。<br>最近好忙，漫漫学习路，加油啊。</p>]]></content>
    
    
    <categories>
      
      <category>备考雅思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English_Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Agent Skills</title>
    <link href="/2026/01/17/Agent-Skills-20260117/"/>
    <url>/2026/01/17/Agent-Skills-20260117/</url>
    
    <content type="html"><![CDATA[<h1 id="Agent-Skills：大模型能力的渐进式封装与按需加载"><a href="#Agent-Skills：大模型能力的渐进式封装与按需加载" class="headerlink" title="Agent Skills：大模型能力的渐进式封装与按需加载"></a>Agent Skills：大模型能力的渐进式封装与按需加载</h1><h3 id="1-前置：什么是-MCP？"><a href="#1-前置：什么是-MCP？" class="headerlink" title="1. 前置：什么是 MCP？"></a>1. 前置：什么是 MCP？</h3><p>MCP（Model Context Protocol，模型上下文协议）本质上是一个大模型调用工具的协议标准，相当于一套通用的口令去调用大模型。</p><p>简单来说，MCP 是一个对于被调用工具和 LLM 来说都简化了的调用口令。LLM 之前调用工具需要生成一串很长的 Token 作为 API 调用接口，再由专门的代码去解析这个 API 找到参数。这里就会遇到一个痛点：不同工具的 API 规范不一样，生成极易出错，而且每次都需要给很长的 Prompt。</p><p><strong>例如，传统查询天气的 Prompt 可能长这样：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;weather_service_api_v4_search&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;endpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;[https://api.weather.com/v1/current](https://api.weather.com/v1/current)&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;auth_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bearer_token&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;parameters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;location_query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Shanghai, CN&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;unit_system&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;metric&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data_fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;temp&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;humidity&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;wind_speed&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>有了 MCP，工具侧暴露通用的、简洁的 API，调用格式高度一致，大大减少了 LLM 侧的调用成本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;get_weather&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;arguments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Shanghai&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>所有的解析、轮询、调用都在 MCP 服务器上完成。目前 Cursor、Claude Desktop 等生态已广泛应用。</p><p><strong>但随着工具量的增加，MCP 也会遇到瓶颈：</strong></p><ul><li><strong>能力不足</strong>：面对复杂任务，智能体需要具备领域知识（比如会调数据库接口但不一定会写 SQL）。</li><li><strong>上下文爆炸</strong>：任务复杂化后，Prompt 依然会累积大量内容，严重影响模型性能。</li></ul><p><strong>Agent Skills 应运而生。</strong></p><hr><h3 id="2-Agent-Skills-是什么？"><a href="#2-Agent-Skills-是什么？" class="headerlink" title="2. Agent Skills 是什么？"></a>2. Agent Skills 是什么？</h3><p>Agent Skills 是标准化的程序性知识封装格式。它将知识和工具解离开：<strong>MCP 负责调用工具，Skills 负责封装知识。</strong> 通过渐进式披露，实现知识的按需逐步加载。</p><h4 id="🛡️-第一层：元数据层-Metadata"><a href="#🛡️-第一层：元数据层-Metadata" class="headerlink" title="🛡️ 第一层：元数据层 (Metadata)"></a>🛡️ 第一层：元数据层 (Metadata)</h4><p>每一个技能文件夹内都有一个 <code>skill.md</code> 文件。顶部的 <code>frontmatter</code> 部分定义了技能的简单描述：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">paper_searcher</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">专门用于搜索</span> <span class="hljs-string">arXiv</span> <span class="hljs-string">和</span> <span class="hljs-string">Google</span> <span class="hljs-string">Scholar</span> <span class="hljs-string">上的最新学术论文，支持按关键词和年份筛选。</span><br><span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">category:</span> <span class="hljs-string">academic</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">your_name</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><p>在 MCP 框架下，初始化时通常要发送完整的参数定义（JSON Schema）。</p><ul><li><strong>MCP 做法</strong>：加载一段约 150 Tokens 的详细 JSON。如果有 10 个工具，连接瞬间就丢掉 2000 个 Token。</li><li><strong>Skills 做法</strong>：仅发送元数据描述，约占 20-30 Tokens。</li></ul><p><img src="/images/Knowledge/Agent/Agent_Skills/contrast.jpg" alt="Agent Skills"></p><h4 id="🛡️-第二层：技能主体"><a href="#🛡️-第二层：技能主体" class="headerlink" title="🛡️ 第二层：技能主体"></a>🛡️ 第二层：技能主体</h4><p>当智能体解析用户指令，发现匹配某个技能时，才会读取完整的 <code>skill.md</code> 文件，获得该技能完整的 MCP 调用接口。通过这种方式，Token 消耗量被大大压缩。</p><h4 id="🛡️-第三层：附加资源-文件夹即技能"><a href="#🛡️-第三层：附加资源-文件夹即技能" class="headerlink" title="🛡️ 第三层：附加资源 (文件夹即技能)"></a>🛡️ 第三层：附加资源 (文件夹即技能)</h4><p>这是这套架构最强悍的地方：<strong>一个技能就是一个全功能的上下文包。</strong></p><p>以<strong>毕业论文格式审查与润色</strong>技能为例，文件夹结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">/skills/paper_polisher/<br>├── SKILL.md             # 核心元数据与激活逻辑<br>├── thesis_rules.json    # 复杂的学校排版规范<br>├── sample_bad_vs_good.md # 润色对照示例 (Few-shot)<br>├── check_format.py      # LaTeX 语法检测脚本<br>└── terminology.csv      # 领域专业词汇对照表<br><br></code></pre></td></tr></table></figure><p>当用户提出需求时，系统会按需加载资源：加载 <code>thesis_rules.json</code> 获取法律依据，加载 <code>terminology.csv</code> 对齐专业术语，甚至运行 <code>check_format.py</code> 进行硬核检测。</p><hr><h3 id="3-Agent-Skills-的核心优势"><a href="#3-Agent-Skills-的核心优势" class="headerlink" title="3. Agent Skills 的核心优势"></a>3. Agent Skills 的核心优势</h3><h4 id="①-极高的语义精准度-Few-shot-Support"><a href="#①-极高的语义精准度-Few-shot-Support" class="headerlink" title="① 极高的语义精准度 (Few-shot Support)"></a>① 极高的语义精准度 (Few-shot Support)</h4><p>MCP 依赖 JSON 描述，适合定义类型，但不擅长描述“风格”。在 JSON 里强插示例会造成 Token 冗余。<br><strong>Skills 的优势</strong>：通过引用 <code>samples.md</code>，在干活时甩给 LLM 几个<strong>顶级范例</strong>（Few-shot Prompting）。LLM 不再盲目猜测，而是有了<strong>手感</strong>，输出质量从 70 分直奔 95 分。</p><h4 id="②-跨语言的工具集成-Hybrid-Execution"><a href="#②-跨语言的工具集成-Hybrid-Execution" class="headerlink" title="② 跨语言的工具集成 (Hybrid Execution)"></a>② 跨语言的工具集成 (Hybrid Execution)</h4><p>文件夹可以携带 Python 或脚本。对于规则极强的任务（如公式闭合检查），脚本比 LLM 更快更准。技能可以先跑脚本，再让 LLM 总结。</p><p><img src="/images/Knowledge/Agent/Agent_Skills/skills_help_ai.jpg" alt="Agent Skills"></p><h4 id="③-私有化与版本隔离"><a href="#③-私有化与版本隔离" class="headerlink" title="③ 私有化与版本隔离"></a>③ 私有化与版本隔离</h4><p>每个文件夹独立。你可以为不同的技能各做一个包，引用不同词库，互不干扰，像插拔式硬盘一样方便。</p><h4 id="④-动态上下文管理-Smart-Context-Loading"><a href="#④-动态上下文管理-Smart-Context-Loading" class="headerlink" title="④ 动态上下文管理 (Smart Context Loading)"></a>④ 动态上下文管理 (Smart Context Loading)</h4><p>系统根据需求只加载文件夹里的某一个文件。相比 MCP 的全量不可拆分，Skills 能进一步节省每一轮对话的成本。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Agent Skills 通过<strong>渐进式披露 + 技能相关文件打包</strong>的方式，实现了 Agent 的按需加载，解决了 MCP 在复杂场景下的知识匮乏与上下文冗余问题。</p>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
      <category>Agent</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日练字:2026-01-15</title>
    <link href="/2026/01/15/Practice_Handwriting_20260115/"/>
    <url>/2026/01/15/Practice_Handwriting_20260115/</url>
    
    <content type="html"><![CDATA[<p>今日份练字，偶尔拿出来写两笔<br><img src="/images/Handwriting/handwriting_20260115.jpg" alt="今日练字"></p>]]></content>
    
    
    <categories>
      
      <category>只要工整一点就好</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Practice_handwriting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备考雅思:2026-01-15</title>
    <link href="/2026/01/15/English_20260115/"/>
    <url>/2026/01/15/English_20260115/</url>
    
    <content type="html"><![CDATA[<p>今日份学习，加油加油<br><img src="/images/English/data_20260115.png" alt="今日学习数据"><br>今日英语学习依然在第一阶段：打基础+学习阅读技巧</p><ul><li><input disabled="" type="checkbox"> 单词过两遍</li><li><input disabled="" type="checkbox"> 语料库听写一遍</li><li><input disabled="" type="checkbox"> 阅读课过一遍</li></ul><h3 id="1-背单词"><a href="#1-背单词" class="headerlink" title="1.背单词"></a>1.背单词</h3><p>今日时间不够<br>复习单词15min 进度</p><h3 id="2-语料库"><a href="#2-语料库" class="headerlink" title="2.语料库"></a>2.语料库</h3><p>听15min 检查10min</p><p>chapter 11 section2</p><p>单词部分听完并学习了新的单词 明天复习</p>]]></content>
    
    
    <categories>
      
      <category>备考雅思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English_Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo上传问题</title>
    <link href="/2026/01/15/Hexo_Upload_Problem/"/>
    <url>/2026/01/15/Hexo_Upload_Problem/</url>
    
    <content type="html"><![CDATA[<p>解决了一个小问题：hexo上传的时候出现两个问题：</p><ol><li>只有标题没有内容</li><li>首页的tag里边显示是example&#x2F;&#x2F;&#x2F;</li></ol><p>因为在<code>_config.yml</code>还没有设定</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attribute">url</span>: <br><span class="hljs-attribute">permalink</span>: <br></code></pre></td></tr></table></figure><p>改过来就可以了</p>]]></content>
    
    
    <categories>
      
      <category>Issues</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今天我对番茄钟的一点重新认识</title>
    <link href="/2026/01/15/Knowledge_About_Pomodoro_Techniquet/"/>
    <url>/2026/01/15/Knowledge_About_Pomodoro_Techniquet/</url>
    
    <content type="html"><![CDATA[<p>番茄钟（Pomodoro Technique）是由 Francesco Cirillo 在 1980 年代提出的一种时间管理方法：将工作划分为 25 分钟的专注时段（称为一个“番茄”），之后休息 5 分钟；每完成四个番茄，进行一次 15–30 分钟的长休息。其核心理念是通过「专注 + 休息」的循环，提升效率、减少分心、避免疲劳，尤其适合容易走神、希望培养专注力的人。</p><p>我一直用番茄钟训练自己的专注力，却始终没体验到公众号或营销号里描述的那种“神奇效果”。相反，我常常感到疲于奔命——像一头必须在限定时间内耕完地的老黄牛，鞭子还没到，就开始喘着粗气。越赶越急，任务反而更难完成。更糟的是，那 5 分钟的休息常常失控：一刷手机就停不下来，结果不仅没恢复精力，还进一步损耗了专注力。</p><p>我的典型模式是这样的：<br>“现在要写一段代码 → 设定 25 分钟 → 时间到，休息 5 分钟 → 任务没做完 → 再来一个番茄……”</p><p>直到今天读到一篇文章，我才恍然大悟：番茄钟真正的价值，或许不是“逼你专注”，而是一个“时间评估工具”。<br>它帮助你将有限的时间片，合理分配给不同的任务，从而看清自己一天的真实产出。</p><p>反思下来，我的问题其实出在两点：</p><ol><li><p>目标模糊，本末倒置<br>我总是“先有时间，后找任务”——盯着 25 分钟倒计时，却没想清楚“这 25 分钟到底要完成什么”。正确的做法应该是：先明确任务，再用番茄钟去分配时间。</p></li><li><p>忽视了番茄钟的“计量”功能<br>番茄钟的本质是“有效工作单位”。一天能完成多少个番茄，直接反映了你的真实高效时长。<br>比如，我可能“工作”了 8 小时，但有效番茄只有 4–5 个。这个数字让我看清：时间去哪儿了？哪些环节在浪费精力？如何优化节奏？</p></li></ol><p>番茄钟不是枷锁，而是镜子。<br>它照见的不是你的懒惰，而是你与时间的真实关系。</p><p>共勉。</p>]]></content>
    
    
    <categories>
      
      <category>方法论</category>
      
      <category>时间管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
